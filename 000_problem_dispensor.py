import random

problems = [
    
]

problems_io_and_bst = [
    2557, 1000, 2558, 10950, 10951, 10952, 10953, 11021, 11022, 11718, 11719, 11720, 11721, 2741, 2742, 2739, 1924, 8393, 10818, 2438, 2439, 2440, 2441, 2442, 2445, 2522, 2446, 10991, 10992, 
    1208, 1654, 2805, 2110, 10815, 10816, 11662
]
# io는 별로 안필요할지도? bst만 먼저 봐볼까.


problems_maybe_later = [
    1168, 1208
]

solved = [
    2745, 1261, 10814, 10828, '1676_factorial_5_count', 10844, 6603, 11726, 1212, 2178, 1525, 1373, 1517, 1759, 5014, 10610, 1978, 2193, 10866, 1934, 1699, 1963, 1744, 2261, 
    2186, 10824, 2156, 9461, 10820, 2003, 11053, 14002, 11722, 2004, 1991, 1697, 10825, 1260, 1182, 2251, 2580, 4963, 2225, 9012, 1476, 7453, 11656, 11655, 1780, 2143, 11727,
    2331, 11005, 1783, 2146, 3108, 11047, 10451, 6588, 1107, 11729, 10819, 1158, 1987, 2133, 10872, 10809, 1967, 1912, 11728, 11052, 11057, 9613, 2632, 1931, 11653, 1707, 2743,
    1929, 9095, 1992, 2609, 10430, 11724, 1167, 7576, 1463, 11652, 11054, 2579, 11576, 1644, 2873, 10799, 10808, 1806, 11399, 11055, 2447, 2011, 1451, 2448, 2667, 11725, 2875, 
    11650, 2089, 9466, 9465, 10989, 10845, 1406, 2751, 11004, 9019, 1850, 11651, 10971
]

solved_others = [
    1085, 1181, 1717
]

solved_reviews = {
    'stack_queue' : ['prog_42583'],


    'sorting' : ['leet_179']
}

# 'https://mangkyu.tistory.com/181' 
problems_not_solved = {
    14500
}
# 구현 골드 문제 거의 스킵한 상황. 너무 시간만 오래걸리는 것들인거 같아서 .. 


# log: (solved, solved again, didn't solve bc already solved,)
log = {
    'jan_18': (4, 1, 1),
    'jan_19': (4, 1, 0),
    'jan_20': (5, 0, 0),
    'jan_21': (3, 2, 2),
    'jan_22': (5, 0, 0),
    'jan_23': (4, 2, 0),
    'jan_24': (5, 0, 3),
    'jan_25': (2, 0, 2),
    'jan_26': (5, 0, 0),
    'jan_27': (4, 1, 0),
    'jan_28': (3, 0, 1),
    'jan_29': (6, 0, 0),
    'jan_30': (4, 1, 1), # 1168은 segment tree로 해야 시간 통과한다고 함. 일단은 보류. 
    'jan_31': (3, 0, 0),
    'feb_02': (4, 6, 1),
    'feb_03': (4, 1, 0),
    'feb_04': (4, 1, 0),
    'feb_05': (4, 1, 0),
    'feb_06': (3, 0, 1),
    'feb_07': (5, 0, 0),
    'feb_08': (1, 1, 1),
    'feb_09': (6, 0, 0),
    'feb_17': (2, 0, 0),
    'feb_18': (2, 0, 0),
    'feb_19': (0, 3, 0)
}

"""
6603 - combinations, permutations 직접 구현 가능하도록
1212 - 예외 상황 .. binary로 바꾸는 함수. 8진법으로 변환하기. 등등. 코테는 테케 없다던데 실수를 줄여서 한번에 미리 여러가지 예외나 다른 경우들을 생각해놓는 연습을 해야겠다. 
1517 - segment tree로도 풀 수 있다고 한다. segment tree공부(https://m.blog.naver.com/ndb796/221282210534)한 후에 https://cantcoding.tistory.com/33 풀이를 참고하자. 
1759 - combinations, permutations 직접 구현 하는거 한번 하긴 해야함. 백트래킹 풀이 한번 살펴보자 https://cotak.tistory.com/125
1978 - 에라토스테네스의 체 파이썬 구현 한번 해볼까
1934 - 최대공약수, 최소공배수.. 예전 백준 강의 풀이만 봤음. 스스로 풀 수 있도록 해야하긴 할 듯. 근데 너무 수학이긴 해서.
2261 - 최단거리의 두 점사이 거리 구하기 문제 - 코드 이해만 하고 베껴서 냈다. 스스로 한번 풀어보기. 
2003 - sliding window / two pointers 문제 - LEET 투포인터 / 슬라이딩 윈도우 관련된 문제들 다시 리뷰 해보자. 스스로 풀 수 있는지 .. 그리고 투포인터/슬라이딩 윈도우 를 어떤 문제들에 고려해야 하는지 감을 잡아야 함.
2004 - 수학 문제.. 원리 이해할 수 있도록. https://tmdrl5779.tistory.com/95
        9! 에 곱해지는 2의 개수를 구하려면, 9//2 + 9//4 + 9//8 을 하면 된다. 이것을 구현한 것이다. 
1697 - 풀엇던거라 스킵함. 근데 왠지 찝찝하다 ㅋ
DP어렵다

7453 - 이분탐색으로도 풀 수 있다고 함. 이분탐색 문제들 풀때 다시 풀어보자. https://steady-coding.tistory.com/326 https://velog.io/@ckstn0778/%EB%B0%B1%EC%A4%80-7453%EB%B2%88-%ED%95%A9%EC%9D%B4-0%EC%9D%B8-%EB%84%A4-%EC%A0%95%EC%88%98-X-1 
2143 - 이 문제도 백준에는 이분탐색에 분류가 되어 있네?
11729 - 하노이 탑 문제. 다시 함 해봐야됨. 
1168 - segment tree문제라고 함. 
11057 - 다시
1987 - 좋은 문제. 다시.
1208 - 백준 분류는 이분탐색, 중간에서 만나기 라는데. 이분탐색 하고 다시 해보자.
1451 - 이런식으로 경우를 나눠서 생각할 수 있을지 몰랐군. 또한 합을 저장해서 최적화 하는 방식. 신기하군. 일종의 DP라고 봐야할듯
2448 - 재귀 분할정복으로 풀 수 있도록.
10971 - 비트마스킹, DP로 더 빠르게 풀 수 있다고 함(이 문제는 입력값이 작으니 DFS(brute force)로 풀 수 있는거지. 더 크면 저렇게 풀어야 함). 그리고 외판원순회 문제(TSP)는 원래 그렇게 푸는게 정석이라고 함. https://suri78.tistory.com/152

"""

'''
한번 이상 실패(로직이 다른 경우):
11727
'''

'''
한번 이상 실패(자잘한 실수 한 경우):
2331
'''

'''
테케나 정답 여부가 주어지지 않는 것을 대비해서 제출 시 정확도를 올릴 수 있도록 연습하기로 했다. 
    한번에 맞출 수 있도록 집중하여 코드 작성하기. 
    예외 나 경계 경우, 테케 생각해보기
    제출 전 실수가 없는지 코드 한번 확인해보기
또한 두시간 안에 1차 8문제, 2차 5문제를 풀어야 하므로 각각 1문제당 15분, 24분이 주어진 것이다. 
    꽤 촉박한 시간이라고 생각이 되고. 따라서 시간안에 풀 수 있도록 연습 해야할 것이다. 
    그래서 문제 풀 때 확실히 실전처럼 시간을 신경써서 연습하기로 하였다. 
    일단 한문제를 풀기 시작하면 중간에 다른일 하지말고 최대한 집중해서 이어갈 수 있도록하고. 가능하면 한번에 여러 문제를 이어서 풀 수 있도록. 집중력 연습도 해야겠다. 
    시간도 좀 재보는중. 
정확도와 속도를 향상시키기 위해서 느낀점
    최악의 상황은 문제를 거의 다 풀었고 푸느라 시간을 썼는데 그 방법이 틀린 경우이다.
    따라서 처음에 확실한 방법을 구체적으로 생각해서, 이론상 맞는 방법이라는 확신이 있다면 코드작성을 시작하는 습관을들이자.
    또한 문제를 잘못 이해한 경우도. 풀이가 틀릴수밖에 없게 된다. 
        따라서 문제를 처음에 제대로 읽어서 
        무슨 문제를 풀어야 하는지, 제약조건은 무엇인지, 출력 조건은 무엇인지 등. 정확히 파악하고 확인해야 한다. 
        특히 "최종적으로 어떤 값을 구해서 내보내야 하는지"를 반드시 확인하고 기억하고 넘어가도록 하자. 
빠른 시간안에 짤 수없는 방향으로 생각을 했기 때문에 코드가 빠르게 완성되지 못하는 것이다. <== 출처: https://plzrun.tistory.com/56#comment8949316 [plzrun's algorithm]
나중에 보면 풀 수 있는 문제인데 확신이 없어서 아이디어가 떠오르지 않을때. 
    그냥 어떤 종류일 것이다. 라고 가정을 하고. 만약 그거라면? 어떻게 풀어야 할까. 라고 생각을 시작해보자.
    ex) 이 문제가 DP라면 어떻게 풀어야 할까. --> 이런식으로
그리고 입력값의 크기로도 대충 판단할 수 있어야 함. 1억정도 단위가 한도라고 보면 될듯 하다. 보통 1억에 1초라고 치면. 알고리즘 문제들은 1초단위로 내기 때문에. 
    예를들어 1912문제의 경우 n의 최대값이 100000(십만)이었는데 2중루프로 코드를 짜면 100억이 된다. 보통 100억 단위가 되는 솔루션은 없기 때문에, 2중 루프를 쓰면 아마 안될것이다.
    라는 감을 얻을 수 있어야 한다. 반대로 입력값이 작다면 브루트포스를 고려할 수도 있어야 겠다. 그런데 그래프 DFS같은 경우는 입력값이 그렇게 크다고 생각하지 않아도 기하급수적으로 처리시간이 길어지는 경우도 있는듯 하다.
좋은 테케를 직접 만들어서 넣어보는 훈련도 해보로독 하자.

완전탐색(브루트포스) 좀 부족한거 같음. 브루트포스 문제를 만났을때 브루트포스로 풀어야 한다는 감이 잘안오는듯 하다. 단순이 n이 작고 다른 방법이 떠오르지 않는다면 고려해보면 되려나(1182 부분수열의 합 문제 같은 경우)?
브루트포스의 유형들에 좀 익숙하지 않은 듯 하다. 특히 그 URDRUURRRLLL 2873롤러코스터 문제랑(이건 그리디로 분류되긴 함.). "1451 직사각형으로 나누기" 문제 같은것들. 
    이런게 브루트포스라는 감을 좀 기억하자. 이런식으로 경우를 나누어서(상황이나 패턴을 분류하고 그룹화하는?) 생각하는 사고방식에 좀 익숙해져야 할 듯 싶다.


유형별 주의사항, 팁, 느낀점
list comprehension에서 for loop 이나 []*n 꼴을 사용할때 항상 조심해야 함. 
DP는 항상 n의 초반상황 예외처리를 신경써야 한다. 예를들어 n이 1이나 2인 경우 index error가 발생하지 않게 처리해주었는지 신경써야 한다. 
DP 메모이제이션 점화식 할때 d[]를 사용해야 하는데 현재 값을 사용하는 실수를 한 적이 있다. (그 반대 경우도 있음)
DP 모듈로 연산 조건 있을때는 그때그때 해주어야 함. 
DFS나 BFS혹은 그래프 등에서 초기 visited처리 신경써주어야 한다. 예외적인 경우가 있을 수 있음. 
    또한 많은 경우에서 visited를 큐나 스택에서 뽑고나서 하는 것이 아니라 넣기 전에 하면 성능상 이점을 얻을 수 있다는 것을 기억하자. 

union-find
    find함수에서 find(parnets[n])해야 하는데 find(n)해버리는 경우가 있다. 주의하자. 

그래프 구현할때 간선의 방향에 대해 잘 생각하고 구현해야 한다. 무방향(양방향)인지, 단방향인지, 단방향이라면 어느쪽을 향하도록 구현해야 할지.

소마 코테 후기들을 보면 몇몇 사람들이 공통적으로 하는 말이 시간을 줄이는 게(즉 최적화) 중요하고 많이 나온다는 것. 
그렇다면 정답을 맞추는 데에만 신경쓰지말고 더 최적화된 더 빠른 풀이가 있다면 그런것들을 좀더 생각해서 공부해야 할거 같다. 
    풀이 과정을 떠올릴때부터, 혹은 푸는 중에도, 최적화할 수 있는 방법이 생각난다면 빼먹지 않고 적용할 수 있도록 즉시 comment해놓는 연습을 하자. 

함수형 형식도 디버깅할 수 있어야 함.

시간복잡도 관점으로 효율적인 풀이를 생각해내는 것이 중요하지만,
    실전에서 가장 중요한 것은 일단은 어떻게든 푸는 것일 것이다. 
    떠오르는 방법이 비효율적인 방법밖에 없더라도, 일정시간 이상 고민했는데도 떠오르지 않는다면,
    우선은 그 비효율적인 방법을 써서라도 문제를 풀고 넘어가야 한다(다만 이때 코드 자체가 너무 비효율적이고, 구현이 어렵고 명확하지 않은 부분이 있는 경우는 제외). 시간관리 해야함. 
    그게 출제의도에 맞는 정답일수도 있다(그럴 가능성이 꽤 크다고 생각해야 한다). (백준 문제풀때도 그런적 많음)
'''

'''
어이없는 실수

range(N)해야하는데 그냥 N 해버리기.
= 해야하는데 ==하기.
popleft 해야하는데 pop하기.
range() 해야하는데 range빼먹고 ()하기.
N이 리스트라서 len(N)을 해야하는데 N을 사용하는 경우.
dfs재귀 방식으로 구현하는데 base case에서 return 안해서 무한루프;
조건문 안으로 들여쓰기를 제대로 안해서 중복 print되는 경우. (이런 거 방지하기 위해서는 의미있는 테케를 입력해볼줄 알아야 함.)
test case 수가 주어져서 반복문 안에서 돌아가는 코드인데 exit()을 넣어버린 경우(남은 테케들이 있는데 전부 스킵해버리게 됨ㅋ). (continue로 대체해서 해결하였다..)
input()이나 split()에 () 빼먹기.

visited 해야하는데 안하기(무한루프 ㅋ)
visited 체킹할때 0으로 마크하기.
DFS, BFS할때 최초 node의 visited 까먹어버리기.
visited[nr][nc] 해야하는데 visited[r][c] 해버리기

띄어쓰기로 구분된 입력 아닌데 실수로 습관대로 input().split() 해버린 적이 있었다. 주의하자.
'''

'''
문제 이해 실수

입력값이 정렬되어 있다는 조건이 없는데 그럴 것이라고 멋대로 assume하기. 이런식으로 조건이 되어 있는지를 명확하게 확인해야 한다. 

'''

print(len(problems), problems[random.randrange(0, len(problems))])